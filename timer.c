//------------------------------------------------------------------------------
//             __             __   ___  __
//     | |\ | /  ` |    |  | |  \ |__  /__`
//     | | \| \__, |___ \__/ |__/ |___ .__/
//
//------------------------------------------------------------------------------

#include "timer.h"
#include <avr/io.h>
#include <util/atomic.h>
#include <avr/interrupt.h>

//------------------------------------------------------------------------------
//      __   ___  ___         ___  __
//     |  \ |__  |__  | |\ | |__  /__`
//     |__/ |___ |    | | \| |___ .__/
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//     ___      __   ___  __   ___  ___  __
//      |  \ / |__) |__  |  \ |__  |__  /__`
//      |   |  |    |___ |__/ |___ |    .__/
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//                __          __        ___  __
//     \  /  /\  |__) |  /\  |__) |    |__  /__`
//      \/  /~~\ |  \ | /~~\ |__) |___ |___ .__/
//
//------------------------------------------------------------------------------

static volatile uint64_t millis = 0; // The millis counter
// volatile means go get it from memory every time
//------------------------------------------------------------------------------
//      __   __   __  ___  __  ___      __   ___  __
//     |__) |__) /  \  |  /  \  |  \ / |__) |__  /__`
//     |    |  \ \__/  |  \__/  |   |  |    |___ .__/
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//      __        __          __
//     |__) |  | |__) |    | /  `
//     |    \__/ |__) |___ | \__,
//
//------------------------------------------------------------------------------

//=============================================================================
void timer_init()
{
  // Timer/Counter 2 initialization
  // Clock source: System Clock
  // Clock value: 250.000 kHz
  // Mode: CTC top=OCR2A
  // OC2A output: Disconnected
  // OC2B output: Disconnected
  // Timer Period: 1 ms
  ASSR=(0<<EXCLK) | (0<<AS2);
  TCCR2A=(0<<COM2A1) | (0<<COM2A0) | (0<<COM2B1) | (0<<COM2B0) | (1<<WGM21) | (0<<WGM20);
  TCCR2B=(0<<WGM22) | (1<<CS22) | (0<<CS21) | (0<<CS20); //prescalar changed from 100
  TCNT2=0x00;
  OCR2A=0x18; // prescale*64 F9----- 18
  OCR2B=0x00;
  // Timer/Counter 2 Interrupt(s) initialization
  TIMSK2=(0<<OCIE2B) | (1<<OCIE2A) | (0<<TOIE2);
}

//==============================================================================
uint64_t timer_get()
{
  return millis;
}

//==============================================================================
void timer_set(uint64_t new_millis)
{
  // This takes time
  // so if interrupt goes off during
  // writing, have to protect the value
  // takes anything in block, and makes it atomic
  // saves state it had, and restore after it's done
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
  {
    millis = new_millis;
  }
}
//------------------------------------------------------------------------------
//      __   __              ___  ___
//     |__) |__) | \  /  /\   |  |__
//     |    |  \ |  \/  /~~\  |  |___
//
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//        __   __  , __
//     | /__` |__)  /__`
//     | .__/ |  \  .__/
//
//------------------------------------------------------------------------------

//==============================================================================
ISR(TIMER2_COMPA_vect)
{
  millis += 1;
}
